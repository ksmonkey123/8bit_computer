package ch.awae.custom8bit.microcode

import ch.awae.custom8bit.microcode.ALUInstruction.*
import ch.awae.custom8bit.microcode.Action.*
import ch.awae.custom8bit.microcode.FlagCondition.*

val INSTRUCTION_SET = mapOf(
    "NSWP" to Op.ALU(0x00, NSWP, READ_ALU, WRITE_REGISTER),
    "SHL" to Op.ALU(0x04, SHL, READ_ALU, WRITE_REGISTER),
    "SHR" to Op.ALU(0x08, SHR, READ_ALU, WRITE_REGISTER),
    // 0x0c:0f available [4]
    "DECC" to Op.ALU(0x10, DEC, READ_ALU, WRITE_REGISTER),
    "INCC" to Op.ALU(0x14, INC, READ_ALU, WRITE_REGISTER),
    "ADDC" to Op.ALU(0x18, ADD, READ_ALU, WRITE_REGISTER),
    "SUBC" to Op.ALU(0x1c, SUB, READ_ALU, WRITE_REGISTER),
    // 0x20:23 available [4]
    "AND" to Op.ALU(0x24, AND, READ_ALU, WRITE_REGISTER),
    "IOR" to Op.ALU(0x28, IOR, READ_ALU, WRITE_REGISTER),
    "XOR" to Op.ALU(0x2c, XOR, READ_ALU, WRITE_REGISTER),
    "NOT" to Op.ALU(0x30, NOT, READ_ALU, WRITE_REGISTER),
    "NAND" to Op.ALU(0x34, NAND, READ_ALU, WRITE_REGISTER),
    "INOR" to Op.ALU(0x38, INOR, READ_ALU, WRITE_REGISTER),
    "XNOR" to Op.ALU(0x3c, XNOR, READ_ALU, WRITE_REGISTER),
    "LADD" to Op.ALU(0x40, ADD, READ_ALU_WITH_LITERAL, WRITE_REGISTER, CARRY_SET),
    "LSUB" to Op.ALU(0x44, SUB, READ_ALU_WITH_LITERAL, WRITE_REGISTER, CARRY_CLEAR),
    "LADDC" to Op.ALU(0x48, ADD, READ_ALU_WITH_LITERAL, WRITE_REGISTER),
    "LSUBC" to Op.ALU(0x4c, SUB, READ_ALU_WITH_LITERAL, WRITE_REGISTER),
    "CMPC" to Op.ALU(0x50, CMP, READ_ALU, WRITE_REGISTER),
    "LAND" to Op.ALU(0x54, AND, READ_ALU_WITH_LITERAL, WRITE_REGISTER),
    "LIOR" to Op.ALU(0x58, IOR, READ_ALU_WITH_LITERAL, WRITE_REGISTER),
    "LXOR" to Op.ALU(0x5c, XOR, READ_ALU_WITH_LITERAL, WRITE_REGISTER),
    "CMP" to Op.ALU(0x60, CMP, READ_ALU, WRITE_REGISTER, CARRY_SET),
    "LNAND" to Op.ALU(0x64, NAND, READ_ALU_WITH_LITERAL, WRITE_REGISTER),
    "LINOR" to Op.ALU(0x68, INOR, READ_ALU_WITH_LITERAL, WRITE_REGISTER),
    "LXNOR" to Op.ALU(0x6c, XNOR, READ_ALU_WITH_LITERAL, WRITE_REGISTER),
    "DEC" to Op.ALU(0x70, DEC, READ_ALU, WRITE_REGISTER, CARRY_CLEAR),
    "INC" to Op.ALU(0x74, INC, READ_ALU, WRITE_REGISTER, CARRY_SET),
    "ADD" to Op.ALU(0x78, ADD, READ_ALU, WRITE_REGISTER, CARRY_CLEAR),
    "SUB" to Op.ALU(0x7c, SUB, READ_ALU, WRITE_REGISTER, CARRY_SET),
    "MOV" to Op(0x80, 0x0f, READ_REGISTER, WRITE_REGISTER),
    "LOAD" to Op(0x90, 0x03, ADDRESS_FROM_LITERAL, READ_MEMORY, WRITE_REGISTER),
    "ILOAD" to Op(0x94, 0x03, ADDRESS_FROM_REGISTERS, READ_MEMORY, WRITE_REGISTER),
    "LLOAD" to Op(0x98, 0x03, READ_LITERAL, WRITE_REGISTER),
    "CLR" to Op(0x9c, 0x03, WRITE_REGISTER),
    "STORE" to Op(0xa0, 0x0c, ADDRESS_FROM_LITERAL, READ_REGISTER, WRITE_MEMORY),
    "ISTORE" to Op(0xa1, 0x0c, ADDRESS_FROM_REGISTERS, READ_REGISTER, WRITE_MEMORY),
    "BRCS" to Op(0xb0, IF_CARRY_SET, ADDRESS_FROM_LITERAL, BRANCH),
    "BRCC" to Op(0xb1, IF_CARRY_CLEAR, ADDRESS_FROM_LITERAL, BRANCH),
    "BRZ" to Op(0xb2, IF_ZERO_SET, ADDRESS_FROM_LITERAL, BRANCH),
    "BRNZ" to Op(0xb3, IF_ZERO_CLEAR, ADDRESS_FROM_LITERAL, BRANCH),
    "BRLZ" to Op(0xb4, IF_NEGATIVE_SET, ADDRESS_FROM_LITERAL, BRANCH),
    "BRGZ" to Op(0xb5, IF_NEGATIVE_CLEAR, IF_ZERO_CLEAR, ADDRESS_FROM_LITERAL, BRANCH),
    "BRNLZ" to Op(0xb6, IF_NEGATIVE_CLEAR, ADDRESS_FROM_LITERAL, BRANCH),
    "BRNGZ" to Op(0xb7, (IF_ZERO_SET or IF_NEGATIVE_SET), ADDRESS_FROM_LITERAL, BRANCH),
    "GOTO" to Op(0xb8, ADDRESS_FROM_LITERAL, BRANCH),
    "RGOTO" to Op(0xb9, ADDRESS_FROM_REGISTERS, BRANCH),
    "SETC 0" to Op(0xf0, CARRY_CLEAR),
    "SETC 1" to Op(0xf1, CARRY_SET),
    "NOP" to Op(0xff),
)


fun compileInstructionSet(): ByteArray {
    val compiledCode = INSTRUCTION_SET.values.flatMap {
        OpcodeCompiler.compile(it)
    }.toMap()

    // generate binary
    val binary = ByteArray(8192) { adr ->
        compiledCode.getOrDefault(adr, 0x00).toByte()
    }

    return binary
}